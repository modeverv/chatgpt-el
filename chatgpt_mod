#!/usr/bin/env node

const puppeteer = require('puppeteer-core');
const convert = require('html-to-text');

const DEBUG = true;
const DELAY = 100; // ms
const TIMEOUT = 8000; // ms

let ENGINE = 'ChatGPT';
let PAGE_URL = 'https://chatgpt.com/';
let FORM_SELECTOR = 'p.placeholder';
let BUTTON_SELECTOR = 'button[data-testid="send-button"]';
let REPLY_SELECTOR = 'div[data-message-author-role="assistant"]';
let REPLY_PER_QUERY = 1;

// フォーカス制御のための関数
async function focusEmacs() {
    const { exec } = require('child_process');
    return new Promise((resolve, reject) => {
        exec('osascript -e \'tell application "Emacs" to activate\'', (error, stdout, stderr) => {
            if (error) {
                debug(`Failed to focus Emacs: ${error}\n`);
                reject(error);
            } else {
                resolve();
            }
        });
    });
}

async function focusEmacs() {
    const { exec } = require('child_process');
    // 少し待ってからフォーカスを変更
    await sleep(500);
    return new Promise((resolve, reject) => {
        exec('osascript -e \'tell application "Emacs" to activate\'', (error, stdout, stderr) => {
            if (error) {
                debug(`Failed to focus Emacs: ${error}\n`);
                reject(error);
            } else {
                resolve();
            }
        });
    });
}


function debug(msg) {
    if (DEBUG) {
        process.stderr.write(msg);
    }
}

async function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

async function connect_to_browser() {
    debug("## connecting\n");
    let browser;
    try {
        browser = await puppeteer.connect({
//            browserURL: 'http://localhost:9000',
            browserURL: 'http://127.0.0.1:9000',
            defaultViewport: null,
        });
    } catch (err) {
        debug('Connection failed: unable to connect localhost:9000\n');
        process.exit(1);
    }
    return browser;
}

async function open_page(browser) {
    debug('## opening\n');
    const pages = await browser.pages();
    for (const page of pages) {
        const url = page.url();
        if (url.indexOf(PAGE_URL) >= 0) {
            await page.bringToFront();
            return page;
        }
    }
    const page = pages[0];
    await page.bringToFront();
    await page.goto(PAGE_URL);
    return page;
}

async function get_text(page, elem) {
    const html = await page.evaluate(el => el.innerHTML, elem);
    let text = convert.convert(html, {
        preserveNewlines: true,
        wordwrap: false,
    });
    text = text.replace(/\n\n+/g, '\n\n');
    return text;
}

function display_diff(last_reply, reply) {
    const last_lines = last_reply.split('\n');
    const lines = reply.split('\n');
    for (let n = last_lines.length - 2; n < lines.length - 2; n++)
        console.log(lines[n]);
}

async function send_query(page, query) {
    debug("## sending\n");
    if (FORM_SELECTOR.startsWith('textarea')) {
        await page.type(FORM_SELECTOR, query);
    } else {
        await page.$eval(FORM_SELECTOR, (el, str) => el.innerText = str, query);
    }
    
    let prev_elems;
    if (BUTTON_SELECTOR == 'press_enter') {
        prev_elems = await page.$$(REPLY_SELECTOR);
        await page.keyboard.press('Enter');
    } else {
        const button = await page.waitForSelector(BUTTON_SELECTOR);
        prev_elems = await page.$$(REPLY_SELECTOR);
        await button.click();
    }

    debug("## waiting display\n");
    while (true) {
        const elems = await page.$$(REPLY_SELECTOR);
        if (elems.length - prev_elems.length >= REPLY_PER_QUERY) {
            break;
        }
        await sleep(200);
    }

    debug("## waiting initial\n");
    let elem;
    let last_reply = '';
    let nretries = 0;
    while (true) {
        const elems = await page.$$(REPLY_SELECTOR);
        elem = elems[elems.length - 1];
        const reply = await get_text(page, elem);
        if (reply.length > 0) {
            display_diff(last_reply, reply);
            last_reply = reply;
            break;
        }
        await sleep(DELAY);
        nretries++;
        if (nretries > 10000 / DELAY) {
            console.log(`No initial reply from ${ENGINE}.`);
            return;
        }
    }

    debug("## streaming\n");
    let reply;
//    let nretries = 0;
    while (true) {
        reply = await get_text(page, elem);
        if (reply.length > last_reply.length) {
            display_diff(last_reply, reply);
            last_reply = reply;
            nretries = 0;
        } else {
            nretries++;
            if (nretries > TIMEOUT / DELAY)
                break;
        }
        await sleep(DELAY);
    }

    debug("## closed\n");
    const lines = reply.split('\n');
    console.log(lines[lines.length - 2]);
    console.log(lines[lines.length - 1]);

    // Emacsにフォーカスを戻す
    try {
        await focusEmacs();
    } catch (error) {
        debug('Failed to switch focus to Emacs\n');
    }
}

function config_gemini() {
    ENGINE = 'Gemini';
    PAGE_URL = 'https://gemini.google.com/';
    FORM_SELECTOR = 'div.textarea';
    BUTTON_SELECTOR = 'mat-icon[fonticon="send"]';
    REPLY_SELECTOR = 'message-content';
    REPLY_PER_QUERY = 1;
}

function config_claude() {
    ENGINE = 'Claude';
    PAGE_URL = 'https://claude.ai/';
    FORM_SELECTOR = 'p[data-placeholder]';
    BUTTON_SELECTOR = 'button[aria-label="Send Message"]';
    REPLY_SELECTOR = 'div[data-test-render-count]';
    REPLY_PER_QUERY = 2;
}

function config_deepseek() {
    ENGINE = 'DeepSeek';
    PAGE_URL = 'https://chat.deepseek.com';
    FORM_SELECTOR = 'textarea#chat-input';
    BUTTON_SELECTOR = 'press_enter';
    REPLY_SELECTOR = 'div[class="ds-markdown ds-markdown--block"]';
    REPLY_PER_QUERY = 1;
}

function config_perplexity() {
    ENGINE = 'Perplexity';
    PAGE_URL = 'https://www.perplexity.ai';
    FORM_SELECTOR = 'textarea[placeholder]';
    BUTTON_SELECTOR = 'press_enter';
    REPLY_SELECTOR = 'div[dir="auto"]';
//    REPLY_SELECTOR = 'div[class="prose text-pretty"]';
//    REPLY_PER_QUERY = 1;
    REPLY_PER_QUERY = 1;
}
// <div dir="auto"><div class="prose text-pretty dark:prose-invert inline leading-normal break-words min-w-0 [word-break:break-word]"><span>大学と高校のテストには大きな違いがあります。以下に主な特徴を説明します。</span>



// プラットフォームチェックを追加
function check_platform() {
    if (process.platform !== 'darwin') {
        console.error('This script is configured for macOS only.');
        process.exit(1);
    }
}

function main() {
    check_platform();
    
    let n = 2;
    while (n < process.argv.length) {
        const arg = process.argv[n];
        if (arg == '-e') {
            let engine = process.argv[n + 1];
            engine = engine.toLowerCase();
            if (engine == 'gemini')
                config_gemini();
            if (engine == 'claude')
                config_claude();
            if (engine == 'deepseek')
                config_deepseek();
            if (engine == 'perplexity')
                config_perplexity();
            n += 2;
        } else if (arg == '-i') {
            (async () => {
                const browser = await connect_to_browser();
                const page = await open_page(browser);
                process.exit(0);
            })();
            n++;
        } else if (arg == '-q') {
            (async () => {
                const query = process.argv[n + 1];
                const browser = await connect_to_browser();
                const page = await open_page(browser);
                await send_query(page, query);
                process.exit(0);
            })();
            n += 2;
        } else {
            console.log(`Invalid command-line argument '${arg}'.`);
            process.exit(0);
        }
    }
}

main();
